Index: mod-uvesafb.sh
===================================================================
--- mod-uvesafb.sh	(wersja 12531)
+++ mod-uvesafb.sh	(kopia robocza)
@@ -40,7 +40,7 @@
 		return
 	fi
 
-	debug "initrd_gen_uvesafb"
+	verbose "initrd_gen_uvesafb"
 	mknod $DESTDIR/dev/mem c 1 1
 	mknod $DESTDIR/dev/tty1 c 4 1
 	inst_d /sbin
Index: mod-scsi.sh
===================================================================
--- mod-scsi.sh	(wersja 12531)
+++ mod-scsi.sh	(kopia robocza)
@@ -39,7 +39,7 @@
 	local n
 	for n in $PRESCSIMODS; do
 		if [ "X$n" = "Xunknown" ]; then
-			debug "Finding SCSI modules using scsi_hostadapter"
+			verbose "Finding SCSI modules using scsi_hostadapter"
 			local mod scsimodules=$(modprobe_conf | awk '/scsi_hostadapter/ { print $3 }')
 			for mod in $scsimodules; do
 				# for now allow scsi modules to come from anywhere. There are some
Index: mod-fbsplash.sh
===================================================================
--- mod-fbsplash.sh	(wersja 12531)
+++ mod-fbsplash.sh	(kopia robocza)
@@ -42,7 +42,7 @@
 	if ! is_yes "$FB_SPLASH"; then
 		return
 	fi
-	debug "Generating fbsplash"
+	verbose "Generating fbsplash"
 
 	if [ -r /etc/sysconfig/fbsplash ]; then
 		. /etc/sysconfig/fbsplash
@@ -64,7 +64,7 @@
 	for res in $FB_SPLASH_RESOLUTIONS; do
 		if [ -f "/etc/splash/$SPLASH_THEME/$res.cfg" ]; then
 			$fbsplash_geninitramfs -c $DESTDIR -r $res $SPLASH_THEME && \
-			debug "Added $res $SPLASH_THEME theme to initramfs."
+			verbose "Added $res $SPLASH_THEME theme to initramfs."
 		else
 			warn "/etc/splash/$SPLASH_THEME/$res.cfg doesn't exist, skipped"
 		fi
Index: mod-udev.sh
===================================================================
--- mod-udev.sh	(wersja 12531)
+++ mod-udev.sh	(kopia robocza)
@@ -41,7 +41,7 @@
 # generate initrd fragment
 # @access	public
 initrd_gen_udev() {
-	debug "Setting up udev..."
+	verbose "Setting up udev..."
 
 	inst_d /sbin /etc/udev
 	inst_exec $udevd /sbin/udevd
@@ -55,7 +55,9 @@
 
 	local e
 	for e in ata_id cdrom_id collect firmware scsi_id v4l_id; do
-		inst_exec $initrd_dir/udev/$e /lib/udev/$e
+		if [ -e "$initrd_dir/udev/$e" ]; then
+			inst_exec $initrd_dir/udev/$e /lib/udev/$e
+		fi
 	done
 
 	# blkid installed by mod-blkid
Index: mod-usbkbd.sh
===================================================================
--- mod-usbkbd.sh	(wersja 12531)
+++ mod-usbkbd.sh	(kopia robocza)
@@ -4,7 +4,7 @@
 # geninitrd mod: usbkbd
 
 find_modules_usbkbd() {
-	debug "Finding USB keyboard modules"
+	verbose "Finding USB keyboard modules"
 
 	if [ "$(echo /sys/class/input/input*)" = "/sys/class/input/input*" ]; then
 		return
@@ -20,9 +20,9 @@
 			if [ "$bInterfaceClass" = "03" -a "$bInterfaceProtocol" = "01" ]; then
 				module=$(readlink $i/device/driver/module)
 				module=$(basename $module)
-	
+
 				if [ -n "$module" ]; then
-					debug "Found USB Keyboard: $(cat $i/name)"
+					verbose "Found USB Keyboard: $(cat $i/name)"
 					modules="$modules $module"
 				fi
 			fi
@@ -34,7 +34,7 @@
 			module=$(basename $module)
 
 			if [ -n "$module" ]; then
-				debug "Found USB Logitech Unifying Device: $(cat $i/name)"
+				verbose "Found USB Logitech Unifying Device: $(cat $i/name)"
 				modules="$modules $module"
 			fi
 		fi
Index: tests/partitions2
===================================================================
--- tests/partitions2	(wersja 0)
+++ tests/partitions2	(wersja 12560)
@@ -0,0 +1,24 @@
+
+major minor  #blocks  name
+
+   3        0   78150744 hda
+   3        1     216846 hda1
+   3        2   20482875 hda2
+   3        3      72292 hda3
+   3        4          1 hda4
+   3        5     136521 hda5
+   3        6    9775521 hda6
+   3        7   46941898 hda7
+   3        8     522081 hda8
+   3       64   78150744 hdb
+   3       65     128488 hdb1
+   3       66      64260 hdb2
+   3       67   10241437 hdb3
+   3       68          1 hdb4
+   3       69    5116671 hdb5
+   3       70    9775521 hdb6
+   3       71    9775521 hdb7
+   3       72    9775521 hdb8
+   3       73   33270583 hdb9
+ 254        0    5107712 dm-0
+   9        6    9775360 md6
Index: tests/initramfs_switchroot.sh
===================================================================
--- tests/initramfs_switchroot.sh	(wersja 12531)
+++ tests/initramfs_switchroot.sh	(kopia robocza)
@@ -3,6 +3,7 @@
 
 . ./setup-test.sh
 proc=${proc:-/proc}
+partitions=$proc/partitions
 flags=$-
 
 mount() {
@@ -10,7 +11,7 @@
 }
 
 mknod() {
-	echo "mknod $@"
+	: echo "mknod $@"
 }
 
 	# parse 'root=xxx' kernel commandline
@@ -21,25 +22,51 @@
 
 		device=
 		eval "$(
-		busybox awk -v c="$ROOT" '
+		busybox awk -v root="$ROOT" '
+			# http://9fans.net/archive/2006/09/261
+			function h2d(str, hstr, res, num, n, digit, i) {
+				hstr = "0123456789abdcef";
+				res = 0;
+				n = split(tolower(str), digit, "");
+
+				for (i = 1; i <= n; i++) {
+					num = index(hstr, digit[i]) - 1;
+					res = res + (num * 16 ^ (n - i));
+				}
+printf("# h2d(%s) -> [%s]\n", str, res);
+
+				return res;
+			}
 			BEGIN {
-				num_pattern_short = "[0-9a-f][0-9a-f][0-9a-f]";
-				num_pattern = "[0-9a-f]" num_pattern_short;
+
+				num_pattern_short = "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]";
+				num_pattern = "[0-9a-fA-F]" num_pattern_short;
 				dev_pattern = "[hms][a-z][a-z]([0-9])+";
 				partition = "";
 				min = -1; maj = -1;
 
-				sub("^0x", "", c);
-				if (c ~ "^" num_pattern_short "$") sub("^", "0", c);
-				if (c ~ "^" num_pattern  "$") {
-					maj = sprintf("%d",substr(c,1,2));
-					min = sprintf("%d",substr(c,3));
+				# see if we have /dev/hdX or hdX, we can just take partition name
+				if (root ~ "^\/dev\/" dev_pattern "$" || root ~ "^" dev_pattern "$") {
+					partition = root
+					sub("^/dev/", "", partition);
+					printf("# partition regexp=%s;\n", partition);
+
+				} else {
+					# unify values first
+					if (root ~ "^" num_pattern_short "$")  {
+						# change "303" => "0x0303"
+						root = "0x0" root
+					} else if (root ~ "^" num_pattern "$")  {
+						# change "0303" => "0x0303"
+						root = "0x" root
+					}
+
+					maj = h2d(substr(root, 3, 2));
+					min = h2d(substr(root, 5, 2));
+printf("# BEGIN: root=[%s] maj=%s, min=%s\n", root, maj, min);
 				}
-				if (c ~ "^\/dev\/" dev_pattern "$") sub("^/dev/","", c);
-				if (c ~ "^" dev_pattern "$") partition = c;
-				printf("# BEGIN: partition=%s; maj=%s, min=%s\n", partition, maj, min);
 			}
-			{ printf("# maj:[%s], min:[%s], part:[%s]\n", $1, $2, $4) }
+{ printf("# maj:[%s], min:[%s], part:[%s]\n", $1, $2, $4) }
 
 			partition && $4 == partition { maj = $1; min = $2; printf("# found partition: %s\n", partition) }
 			$1 == maj && $2 == min { partition = $4; printf("# found maj and min: %s, %s\n", maj, min)}
@@ -52,7 +79,7 @@
 					printf("device=/dev/%s;\n", partition);
 				}
 			}
-			' $proc/partitions
+			' $partitions
 		)"
 
 		if [ -z "$device" ]; then
@@ -74,7 +101,7 @@
 #	echo "init=$init"
 }
 
-proc=.
+partitions=./partitions
 ROOTFS=xfs
 
 # We support passing root as hda3 /dev/hda3 0303 0x0303 and 303
@@ -102,3 +129,22 @@
 runtest <<'EOF'
 mount -t xfs -r /dev/sda3 /newroot
 EOF
+
+ROOT=805
+runtest <<'EOF'
+mount -t xfs -r /dev/sda5 /newroot
+EOF
+
+# lilo for dm-0
+partitions=./partitions2
+ROOT=fe00
+runtest <<'EOF'
+mount -t xfs -r /dev/dm-0 /newroot
+EOF
+
+# lilo for dm-0
+partitions=./partitions2
+ROOT=FE00
+runtest <<'EOF'
+mount -t xfs -r /dev/dm-0 /newroot
+EOF
Index: tests/partitions
===================================================================
--- tests/partitions	(wersja 12531)
+++ tests/partitions	(kopia robocza)
@@ -4,6 +4,7 @@
    8        1      40131 sda1
    8        2    8008402 sda2
    8        3  480335467 sda3
+   8        5  384475581 sda5
    8       16  488386584 sdb
    8       17      40131 sdb1
    8       18    8008402 sdb2
Index: mod-luks.sh
===================================================================
--- mod-luks.sh	(wersja 12531)
+++ mod-luks.sh	(kopia robocza)
@@ -34,7 +34,7 @@
 
 	local dev dm_name=${node#/dev/mapper/}
 	if [ "$node" = "$dm_name" ]; then
-		debug "is_luks: $node is not device mapper name"
+		verbose "is_luks: $node is not device mapper name"
 		return 1
 	fi
 
@@ -47,9 +47,9 @@
 	fi
 
 	if [ $rc = 0 ]; then
-		debug "is_luks: $node is cryptsetup luks"
+		verbose "is_luks: $node is cryptsetup luks"
 	else
-		debug "is_luks: $node is not cryptsetup luks"
+		verbose "is_luks: $node is not cryptsetup luks"
 	fi
 	return $rc
 }
@@ -95,7 +95,7 @@
 	initrd_gen_devices
 	# TODO: 'udevadm settle' is called by lukssetup, is udev optional?
 
-	debug "luks: process /etc/crypttab $LUKSNAME"
+	verbose "luks: process /etc/crypttab $LUKSNAME"
 	luks_crypttab $LUKSNAME
 }
 
@@ -144,7 +144,7 @@
 				inst $key $keyfile
 			fi
 
-			debug "+ cryptsetup ${keyfile:+-d $keyfile} luksOpen '$src' '$dst'"
+			verbose "+ cryptsetup ${keyfile:+-d $keyfile} luksOpen '$src' '$dst'"
 			add_linuxrc <<-EOF
 			# cryptsetup can be called twice and in case on crypt on lvm only second
 			# will succeed because there will be no src device in first cryptsetup call
Index: mod-bootsplash.sh
===================================================================
--- mod-bootsplash.sh	(wersja 12531)
+++ mod-bootsplash.sh	(kopia robocza)
@@ -28,7 +28,7 @@
 	fi
 	local target="$1"
 
-	debug "Generating bootsplash"
+	verbose "Generating bootsplash"
 
 	if [ ! -x /bin/splash.bin ]; then
 		warn "Failed to execute /bin/splash.bin. Is bootsplash package installed?"
@@ -54,7 +54,7 @@
 	for res in $BOOT_SPLASH_RESOLUTIONS; do
 		if [ -f "/etc/bootsplash/themes/$THEME/config/bootsplash-$res.cfg" ]; then
 			$bootsplash_geninitramfs -s -f "/etc/bootsplash/themes/$THEME/config/bootsplash-$res.cfg" >> "$target" && \
-			debug "Added $res $THEME theme to initrd."
+			verbose "Added $res $THEME theme to initrd."
 		else
 			warn "/etc/bootsplash/themes/$THEME/config/bootsplash-$res.cfg doesn't exist, skipped"
 		fi
Index: mod-suspend.sh
===================================================================
--- mod-suspend.sh	(wersja 12531)
+++ mod-suspend.sh	(kopia robocza)
@@ -36,7 +36,7 @@
 		# save suspend VG int oseparate var
 		LVM_SUSPENDVG=$LVM_VGVOLUMES
 		LVM_VGVOLUMES=$vgvolumes
-		debug "suspend device is on LVM"
+		verbose "suspend device is on LVM"
 	fi
 }
 
@@ -47,7 +47,7 @@
 		return
 	fi
 
-	debug "Setting up suspend..."
+	verbose "Setting up suspend..."
 
 	mknod $DESTDIR/dev/snapshot c 10 231
 	mkdir -p $DESTDIR${resume_dev%/*}
Index: mod-blkid.sh
===================================================================
--- mod-blkid.sh	(wersja 12531)
+++ mod-blkid.sh	(kopia robocza)
@@ -22,7 +22,7 @@
 	if ! is_yes "$USE_BLKID"; then
 		return
 	fi
-	debug "Adding BLKID support to initrd"
+	verbose "Adding BLKID support to initrd"
 
 	inst_exec $blkid /bin/blkid
 	initrd_gen_devices
Index: mod-nfs.sh
===================================================================
--- mod-nfs.sh	(wersja 12531)
+++ mod-nfs.sh	(kopia robocza)
@@ -56,7 +56,7 @@
 
 	# use root=/dev/ram0 init=/linuxrc when starting kernel or you will
 	# have problems like init(XX) being child process of swapper(1).
-	debug "Adding rootfs on NFS support to initrd (dhcp)"
+	verbose "Adding rootfs on NFS support to initrd (dhcp)"
 	mknod "$DESTDIR/dev/urandom" c 1 9
 	mkdir "$DESTDIR/newroot"
 	add_linuxrc <<-'EOF'
Index: mod-condecor.sh
===================================================================
--- mod-condecor.sh	(wersja 12531)
+++ mod-condecor.sh	(kopia robocza)
@@ -26,7 +26,7 @@
 	if ! is_yes "$FB_CON_DECOR"; then
 		return
 	fi
-	debug "Generating fbcondecor"
+	verbose "Generating fbcondecor"
 
 	if [ -r /etc/sysconfig/splash ]; then
 		. /etc/sysconfig/splash
@@ -48,7 +48,7 @@
 	for res in $FB_SPLASH_RESOLUTIONS; do
 		if [ -f "/etc/splash/$SPLASH_THEME/$res.cfg" ]; then
 			$condecor_geninitramfs -c $DESTDIR -r $res $SPLASH_THEME && \
-			debug "Added $res $SPLASH_THEME theme to initramfs."
+			verbose "Added $res $SPLASH_THEME theme to initramfs."
 		else
 			warn "/etc/splash/$SPLASH_THEME/$res.cfg doesn't exist, skipped"
 		fi
Index: geninitrd
===================================================================
--- geninitrd	(wersja 12531)
+++ geninitrd	(kopia robocza)
@@ -79,8 +79,12 @@
 	msg "WARNING: $*" >&2
 }
 
+verbose() {
+	[ x"$verbose" = x"-v" ] && msg "$*" >&3
+}
+
 debug() {
-	[ -n "$verbose" ] && msg "$*" >&2
+	[ x"$verbose" = x"-v -v" ] && msg "$*" >&3
 }
 
 # aborts program abnormally
@@ -96,7 +100,7 @@
 	for x in "$@"; do
 		if [ -x "$x" ]; then
 			echo $x
-			debug "find_tool: found $x"
+			verbose "find_tool: found $x"
 			return 0
 		fi
 	done
@@ -402,8 +406,11 @@
 	local dest=$1
 	set -- $src
 	local parentDir=$(dirname $DESTDIR$dest)
-	[ ! -d "$parentDir" ] && (debug "+ mkdir -p $parentDir"; mkdir -p $parentDir)
-	debug "+ cp $* $DESTDIR$dest"
+	if [ ! -d "$parentDir" ]; then
+		verbose "+ mkdir -p $parentDir"
+		mkdir -p $parentDir
+	fi
+	verbose "+ cp $* $DESTDIR$dest"
 	cp -HR "$@" "$DESTDIR$dest"
 }
 
@@ -457,7 +464,7 @@
 		if [ ! -e $DESTDIR$libdir ]; then
 			libdir=$(dirname "$libdir")
 			inst_d $libdir
-			debug "+ ln -s /$_lib $DESTDIR$libdir"
+			verbose "+ ln -s /$_lib $DESTDIR$libdir"
 			ln -s /$_lib $DESTDIR$libdir
 		fi
 	fi
@@ -515,7 +522,7 @@
 		devpath=$(readlink -f "$devpath")
 	fi
 
-	debug "Finding modules for device path $devpath"
+	verbose "Finding modules for device path $devpath"
 
 	if is_luks "$devpath"; then
 		find_modules_luks "$devpath"
@@ -631,7 +638,7 @@
 	local module="$1"
 	local firmware_files="$2"
 
-	debug "Adding Firmwares ($firmware_files) to initrd for module $module"
+	verbose "Adding Firmwares ($firmware_files) to initrd for module $module"
 	# firmware not yet installed
 	if [ ! -f "$DESTDIR/lib/firmware/firmware.sh" ]; then
 		inst_d /lib/firmware
@@ -698,7 +705,7 @@
 			options="scan=sync $options"
 		fi
 
-		if [ -n "$verbose" ]; then
+		if [ x"$verbose" = x"-v" ]; then
 			s=""
 			if [ "$options" ]; then
 				s="$s with options [$options]"
@@ -706,7 +713,7 @@
 			if [ "$usleep" ]; then
 				s="$s and $usleep usleep"
 			fi
-			debug "Loading module [$module]$s"
+			verbose "Loading module [$module]$s"
 		fi
 
 		if [ -n "$firmware" ]; then
@@ -757,8 +764,9 @@
 
 
 initrd_gen_setrootdev() {
-	debug "Adding rootfs finding based on kernel cmdline root= option support."
+	verbose "Adding rootfs finding based on kernel cmdline root= option support."
 	busybox_applet ls
+	debug "Current /proc/partitions:\n$(sed -e 's,^,> ,' /proc/partitions)"
 	add_linuxrc <<-'EOF'
 		if [ "${ROOT##/dev/}" != "${ROOT}" ]; then
 			rootnr="$(busybox awk -v rootnode="${ROOT##/dev/}" '$4 == rootnode { print 256 * $1 + $2 }' /proc/partitions)"
@@ -783,24 +791,58 @@
 
 	# parse 'root=xxx' kernel commandline
 	# We support passing root as hda3 /dev/hda3 0303 0x0303 and 303
+
+	# from lilo-23.2/readme/README:
+	# root=<device> changes the root device. This overrides settings that may
+	# have been made in the boot image and on the LILO command line. <device> is
+	# either the hexadecimal device number or the full path name of the device,
+	# e.g. /dev/hda3 [*]
+	#
+	#  *  The device names are hard-coded in the kernel. Therefore, only the
+	#	  "standard" names are supported and some less common devices may not be
+	#	  recognized. In those cases, only numbers can be used.
 	add_linuxrc <<-'EOF'
 		device=
-		eval "$(busybox awk -v c="$ROOT" '
+		eval "$(busybox awk -v root="$ROOT" '
+			# http://9fans.net/archive/2006/09/261
+			function h2d(str, hstr, res, num, n, digit, i) {
+				hstr = "0123456789abdcef";
+				res = 0;
+				n = split(tolower(str), digit, "");
+
+				for (i = 1; i <= n; i++) {
+					num = index(hstr, digit[i]) - 1;
+					res = res + (num * 16 ^ (n - i));
+				}
+
+				return res;
+			}
 			BEGIN {
-				num_pattern_short = "[0-9a-f][0-9a-f][0-9a-f]";
-				num_pattern = "[0-9a-f]" num_pattern_short;
+
+				num_pattern_short = "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]";
+				num_pattern = "[0-9a-fA-F]" num_pattern_short;
 				dev_pattern = "[hms][a-z][a-z]([0-9])+";
 				partition = "";
 				min = -1; maj = -1;
 
-				sub("^0x", "", c);
-				if (c ~ "^" num_pattern_short "$") sub("^", "0", c);
-				if (c ~ "^" num_pattern  "$") {
-					maj = sprintf("%d",substr(c,1,2));
-					min = sprintf("%d",substr(c,3));
+				# see if we have /dev/hdX or hdX, we can just take partition name
+				if (root ~ "^\/dev\/" dev_pattern "$" || root ~ "^" dev_pattern "$") {
+					partition = root
+					sub("^/dev/", "", partition);
+
+				} else {
+					# unify values first
+					if (root ~ "^" num_pattern_short "$")  {
+						# change "303" => "0x0303"
+						root = "0x0" root
+					} else if (root ~ "^" num_pattern "$")  {
+						# change "0303" => "0x0303"
+						root = "0x" root
+					}
+
+					maj = h2d(substr(root, 3, 2));
+					min = h2d(substr(root, 5, 2));
 				}
-				if (c ~ "^\/dev\/" dev_pattern "$") sub("^/dev/","", c);
-				if (c ~ "^" dev_pattern "$") partition = c;
 			}
 
 			partition && $4 == partition { maj = $1; min = $2; }
@@ -877,7 +919,7 @@
 		compressors="$mode"
 	fi
 
-	debug "finding compressor: $compressors (via $mode)"
+	verbose "finding compressor: $compressors (via $mode)"
 	# check for compressor validity
 	local c prog map=/boot/System.map-$kernel
 	for c in $compressors; do
@@ -917,7 +959,7 @@
 		fi
 	done
 
-	debug "using gzip for compressor (fallback)"
+	verbose "using gzip for compressor (fallback)"
 	echo gzip
 }
 
@@ -1051,7 +1093,12 @@
 		exit 0
 		;;
 	-v)
-		verbose=-v
+		if [ x"$verbose" = x"-v" ]; then
+			verbose="-v -v"
+		else
+			verbose="-v"
+		fi
+		exec 3>&1
 		;;
 	--compress)
 		COMPRESS=$2
@@ -1136,7 +1183,7 @@
 kernel_version=$(echo "$kernel" | awk -F. '{gsub(/[_-].*/, "", $0); print sprintf("%03d%03d",$1,$2)}')
 kernel_version_long=$(echo "$kernel" | awk -F. '{gsub(/[_-].*/, "", $0); print sprintf("%03d%03d%03d",$1,$2,$3)}')
 
-debug "# $GENINITRD_RCSID (geninitrd)"
+verbose "# $GENINITRD_RCSID (geninitrd)"
 debug "Using _lib: $_lib"
 debug "Using initrd_dir: $initrd_dir"
 
@@ -1234,7 +1281,7 @@
 fi
 
 find_root "$fstab" || exit
-debug "Using $rootdev as device for rootfs"
+verbose "Using $rootdev as device for rootfs"
 
 find_modules_for_devpath "$rootdev"
 
@@ -1257,11 +1304,11 @@
 find_modules_fbsplash
 
 if [ -n "$ifneeded" -a -z "$MODULES" ]; then
-	debug "No modules are needed -- not building initrd image."
+	verbose "No modules are needed -- not building initrd image."
 	exit 0
 fi
 
-debug "Building initrd..."
+verbose "Building initrd..."
 DESTDIR=$(mktemp -d -t initrd.XXXXXX) || die "mktemp failed"
 RCFILE="$DESTDIR/linuxrc"
 > "$RCFILE"
@@ -1432,12 +1479,14 @@
 initrd_gen_fbsplash
 initrd_gen_fbcondecor
 
+debug "Current /linuxrc:\n$(sed -e 's,^,> ,' $DESTDIR/linuxrc)"
+
 IMAGE=$(mktemp -t initrd.img-XXXXXX) || die "mktemp failed"
 
 IMAGESIZE=$(du -ks $DESTDIR | awk '{print int(($1+1023+512)/1024)*1024}')
-debug "image size: $IMAGESIZE KiB ($DESTDIR)"
+verbose "image size: $IMAGESIZE KiB ($DESTDIR)"
 
-debug "Creating $INITRDFS image $IMAGE"
+verbose "Creating $INITRDFS image $IMAGE"
 case "$INITRDFS" in
   ext2)
 	dd if=/dev/zero of="$IMAGE" bs=1k count="$IMAGESIZE" 2> /dev/null
@@ -1482,7 +1531,7 @@
 
 if ! is_no "$COMPRESS"; then
 	compressor=$(find_compressor "$COMPRESS")
-	debug "Compressing $target with $compressor"
+	verbose "Compressing $target with $compressor"
 
 	# TODO: the image name (specified from kernel.spec) already contains
 	# extension, which is .gz most of the time.
Index: mod-lvm.sh
===================================================================
--- mod-lvm.sh	(wersja 12531)
+++ mod-lvm.sh	(kopia robocza)
@@ -83,14 +83,14 @@
 find_modules_lvm() {
 	local devpath="$1"
 
-	debug "LVM: $devpath is LVM node"
+	verbose "LVM: $devpath is LVM node"
 
 	local vg=$(find_lvm_vg "$devpath")
-	debug "LVM VG for $devpath: $vg"
+	verbose "LVM VG for $devpath: $vg"
 	LVM_VGVOLUMES=$(echo $LVM_VGVOLUMES $vg | tr ' ' '\n' | sort -u)
 
 	local pv=$(find_lvm_pv "$vg")
-	debug "LVM PV for $vg: $pv"
+	verbose "LVM PV for $vg: $pv"
 	PVDEVICES=$(echo $PVDEVICES $pv | tr ' ' '\n' | sort -u)
 
 	if [ -n "$PVDEVICES" ]; then
@@ -110,7 +110,7 @@
 		die "LVM version $LVMTOOLSVERSION is not supported."
 	fi
 
-	debug "LVM v$LVMTOOLSVERSION enabled"
+	verbose "LVM v$LVMTOOLSVERSION enabled"
 	have_lvm=yes
 }
 
@@ -122,7 +122,7 @@
 		return
 	fi
 
-	debug "Adding LVM support to initrd"
+	verbose "Adding LVM support to initrd"
 	inst_d /tmp /newroot
 	inst_exec $lvm /bin/lvm.static
 
@@ -170,7 +170,7 @@
 			echo '	filter = [' >> "$DESTDIR/etc/lvm.conf"
 			local dev
 			for dev in $lvm_ignore_devices; do
-				debug "LVM v2: ignore device $dev"
+				verbose "LVM v2: ignore device $dev"
 				printf '  "r|^%s.*|",\n' $dev
 			done >> "$DESTDIR/etc/lvm.conf"
 			echo ']' >> "$DESTDIR/etc/lvm.conf"
Index: mod-md.sh
===================================================================
--- mod-md.sh	(wersja 12531)
+++ mod-md.sh	(kopia robocza)
@@ -46,7 +46,7 @@
 	local found raidlevel
 
 	if [ -f /etc/mdadm.conf ]; then
-		debug "Finding RAID details using mdadm for rootdev=$1"
+		verbose "Finding RAID details using mdadm for rootdev=$1"
 		eval `($mdadm -v --examine --scan --config=/etc/mdadm.conf 2> /dev/null;$mdadm -v --detail --scan --config=/etc/mdadm.conf 2> /dev/null) | awk -v rootdev="$1" '
 		BEGIN {
 			found = "no";
@@ -119,7 +119,7 @@
 		die "RAID devices not found for \"$1\", check your configuration!"
 	fi
 
-	debug "md: found rootdev=$1 on device $rootdev_new with devices list ${dev_list}"
+	verbose "md: found rootdev=$1 on device $rootdev_new with devices list ${dev_list}"
 
 	rootdev_nr=$(( $rootdev_nr + 1 ))
 	eval "rootdev${rootdev_nr}=\"$rootdev_new\""
@@ -137,7 +137,7 @@
 	if ! is_yes "$have_md"; then
 		return
 	fi
-	debug "Setting up mdadm..."
+	verbose "Setting up mdadm..."
 
 	inst_exec $mdassemble /bin/mdassemble
 
@@ -161,7 +161,7 @@
 	for nr in `seq 1 $rootdev_nr`; do
 		eval cr_rootdev="\$rootdev${nr}"
 		eval cr_dev_list="\$dev_list${nr}"
-		debug echo "Setting up array ($cr_rootdev = $cr_dev_list)"
+		verbose "Setting up array ($cr_rootdev = $cr_dev_list)"
 
 		[ "$cr_rootdev" = "/dev/md0" ] && do_md0=0
 
Index: mod-ide.sh
===================================================================
--- mod-ide.sh	(wersja 12531)
+++ mod-ide.sh	(kopia robocza)
@@ -42,7 +42,7 @@
 
 	local n
 	if [ "$kernel_version_long" -lt "002004021" ]; then
-		debug "Finding IDE modules for kernels <= 2.4.20"
+		verbose "Finding IDE modules for kernels <= 2.4.20"
 		for n in $PREIDEMODSOLD; do
 			find_module "$n"
 		done
@@ -50,7 +50,7 @@
 		local tryauto=1
 		for n in $PREIDEMODS; do
 			if [ "X$n" = "Xunknown" ]; then
-				debug "Finding IDE modules using ide_hostadapter"
+				verbose "Finding IDE modules using ide_hostadapter"
 				local mod idemodules=$(modprobe_conf | awk '/ide_hostadapter/ { print $3 }')
 				for mod in $idemodules; do
 					tryauto=0
@@ -60,7 +60,7 @@
 				if [ "$tryauto" -eq 1 ]; then
 					# If tryauto {{{
 					if [ -r /usr/share/pci-database/ide.pci -a -r /proc/bus/pci/devices ]; then
-						debug "Finding IDE modules using PCI ID database"
+						verbose "Finding IDE modules using PCI ID database"
 						# Finding IDE modules using PCI ID database {{{
 						if is_yes "${ide_only_root}"; then
 							if [ -f /sys/block/${rootblkdev}/device/../../vendor -a -f /sys/block/${rootblkdev}/device/../../device ]; then
Index: mod-multipath.sh
===================================================================
--- mod-multipath.sh	(wersja 12531)
+++ mod-multipath.sh	(kopia robocza)
@@ -78,7 +78,7 @@
 		return 1
 	fi
 
-	debug "Finding modules for dm-multipath (WWID=$MPATH_WWID)"
+	verbose "Finding modules for dm-multipath (WWID=$MPATH_WWID)"
 	have_multipath=yes
 
 	local p list
Index: TODO
===================================================================
--- TODO	(wersja 12531)
+++ TODO	(kopia robocza)
@@ -21,3 +21,8 @@
 
 - make extract-ikconfig() able to read config from vmlinuz (in case of CONFIG_IKCONFIG=y instead of =m)
 - make lvm2 not to complain about fds, use LVM_SUPPRESS_FD_WARNINGS=1
+
+- mount --move /dev to /newroot/dev when /dev is devtmpfs
+this would fix cases /newroot/dev being mounted readonly and /dev/ not containing console node.
+
+need to think how _not_ to do that in case of /newroot os containing static /dev
Index: functions
===================================================================
--- functions	(wersja 12531)
+++ functions	(kopia robocza)
@@ -157,8 +157,16 @@
 # node can be /dev/dm-0, /dev/mapper/name
 # @return	subsystem name
 dm_subsystem() {
-	local node="$1"
-	dmsetup info -c --noheadings -o subsystem $node
+	local node="$1" out
+	out=$(dmsetup info -c --noheadings -o subsystem $node)
+	if [ $? -eq 0 -a -n "$out" ]; then
+		echo "$out"
+		return
+	fi
+
+	# for very old kernels (2.6.16), subsystem is empty, assume LVM
+	# TODO: fix this if needed to have crypt as well
+	echo "LVM"
 }
 
 # resolve any dm node to it's full path in /dev/mapper
Index: mod-sata.sh
===================================================================
--- mod-sata.sh	(wersja 12531)
+++ mod-sata.sh	(kopia robocza)
@@ -4,7 +4,7 @@
 # geninitrd mod: sata
 
 find_modules_sata() {
-	debug "Finding SATA modules (class=0x0106)"
+	verbose "Finding SATA modules (class=0x0106)"
 
 	# Classes (we want only 0106)
 	# http://pci-ids.ucw.cz/read/PD/01
